大家好，今天给大家分享的方向是VI-ReID，也就是可见光-红外的跨模态场景下的行人再识别，分享的论文是MPANet，我们之前未涉及跨模态方面的ReID，因此今天的议程分为两部分，首先我带大家总结一下VI-ReID方向大概是在搞什么，然后再看一下今天的论文。

首先我们回顾一下常见的ReID公开数据集，比如MSMT17和Market1501，我们可以说其中大部分图像都是在白天，或者说光线比较充足的场景下采集的。然而如果在一台设备上进行不间断的再识别，那么在夜晚光线较暗时，可见光监控头成像可能整体都是暗的，采到的图像基本就不包含啥信息了。因此这时使用红外成像更加合适，比如最右边圆圈中这组图像就是近红外采集的，可见在低光照场景下，还是能从红外图像中分辨出行人与背景。再者，现在部分监控头是双摄的，也就是在检测到光照较暗时自动换用红外摄像头，像我们之前在燕电，大概在晚上六七点，一些摄像头就会采到近红外图像，而不再是彩色RGB图像了。所以说在ReID实际落地中，红外数据是我们有必要考虑到的，但加入红外数据后，只在可见光数据上训练的模型表现往往会变差，因为可见光和红外的成像原理不一样，两个模态间的gap比较大。现在我们可以暂且理解红外为单通道的灰度图嘛，直观上相比于RGB图像丢失了色彩和一些纹理信息，所以我们要想办法减小两种模态间的gap才能利用上红外数据。这样，我们很自然地知道了VI-ReID的任务目标：给定一种模态，比如说可见光图像作为query查询，而另一种模态，比如果红外图像作为gallery底库，也可以很准确地再识别。

（平凡地对齐全局特征，难以利用上模态特有细粒度信息,导致模型泛化能力退化）
红外和可见光的模态差异其一是，同ID不同模态特征分布差距较大。其二，两种模态成像原理不同啊，模型能从中学到的信息也不同，两者共有的主要是行人轮廓，姿态上的信息。设想一下，我们如果只是什么也不做，利用模型已有的loss拉近图1中相同ID的两种模态的特征，那么可能的情况是模型被驱使着学到更通用，或者说两种模态共有的全局level的特征，但是淡化区分度更高的局部level的特征，那这样模型在Reid任务上的泛化能力会退化。比如同ID不同模态下行人衣服纹理这个差别是比较大的，所以我们对齐后的特征不容易体现出这一局部信息。所以如何在融合不同模态时，利用上这些留在模态内部，或者说不同模态间视觉表现差距很大的信息是一个难点。

在讲跨模态问题的思路之前我们先来看看研究中常用的数据集，也就是中山大学的MM01数据集和RegDB数据集，前者是一个包含4w+张图像，491个行人的大数据集，而RegDB是一个8k+图像的小型数据集。首先两者的红外图像有些差异，SYSU中使用的是近红外摄像头，而RegDB使用的远红外热成像，简单的讲就是两者成像所用的波长不一样，远红外光和可见光差异更大，因此RegDB中红外图像纹理细节损失地更多，这点我们从样例图片就能看出来，但研究中通常不会区别对待这两个数据集。RegDB中每个行人都有10张可见光图像和10张红外图，是模态平衡的数据集，因此在RegDB的测试集上，一般都是RGB和IR相互作为query进行跨模态查询。而MM01中IR图像较少，模型评估一般就是用红外图像去匹配可见光图像。另外，RegDB的两个camera就是在同一个位置上，而MM01的场景变化和图像数更多，后者也许更能验证模型的泛化能力

在VI-Reid方向，为了克服我们之前说过的跨模态信息损失的问题，一般的方法分为两种，也就是首先在两个模态上取交集或并集，前者可以总结为模态共享的特征学习，那这种方法往往会在对齐模态之前，设计一些结构保留住模态内部，那些区分度高的特征，从而提高reid任务上的泛化能力嘛。而后者，也就是模态信息补偿的思路就是根据输入的模态生成另一种模态的图像，或者中间特征张量，然后再对齐两种模态下的特征。这种思路的难点就是加入容易受噪的生成式结构后怎么得到可靠的输出，尤其是如果要用红外生成可见光特征，红外其实本身信息量会比可见光少很多，这样的话还是比较困难的。示例图中实线框住的是原始输入的模态特征，虚线框住的是对齐后的特征

接下来我们简单看一下一些已有的工作，首先是生成式的方案，像AlignGAN就是利用可见光图像生成红外图像再送到后续网络中对齐特征。当然由于可见光/红外间的模态差异较大，比较难生成高质量的图像，22年的FMCNet等工作的思路就是更端到端一点，只生成中间的特征，通常是对得到的输出解耦出两种模态下特定的特征再送后续GAN

然后就是模态共享特征学习，像我们之前说的，这些方法通常要同时对齐全局和细粒度的特征，从而有效利用两个模态。比如说深层网络中浅层主要是体现底层视觉信息，而深层才是人员ID相关的信息，所以像23年的DEEN等就是融合了多level的特征。再比如说22年DTRM等工作就是把我们之前分享过的PCB的那种空间分块之类的方法应用到跨模态数据上，主要是融合行人的全局特征和部位特征。还有，我们可以引入注意力机制，这种思路的优点是模型会少一些先验，注意力权重能让模型学习到应该更关注通道上或者空间上的哪些区域，这对于提取模态共有的全局特征或局部特征都是挺有用的，今天要分享的MPANet就是主要利用了空间注意力。当然其他的思路还有不少，比如说，不从模型结构入手，而是设计度量损失函数，使得无论何种模态，输出的特征都要在不同ID间具有区分性，我们就不再细说了。

接下来我们解读一下MPANet这篇工作，它要解决的问题，就像我们一开始说的一样，简单地对齐可见光红外的全局特征的话，粒度就比较粗。这样一些细粒度的信息由于在模态间差异太大，就不好体现在全局特征里，也就是信息损失，学习不到了。作者强调的就是要在对齐模态前找出一些细粒度信息，也就是标题里的nuance，文章中指的是空间上的局部特征，这篇工作主要的内容就是用空间注意力生成多种局部特征，然后同时对齐全局特征和局部的。
作者是通过一个例子来支持他的motivation的，图中是一个平凡的backbone，不同id红外特征比较接近，这就说明红外模态的特征信息熵比较小。这可能是因为红外图像包含的id相关的信息一般比可见光的要小，因此模态对齐带来的信息损失更明显。我们再细看一下对应图像，一些局部信息，比如说头，裤腿，应该还是对reid有帮助的，所以有必要从全局中把这些区分性强的nuance抽离出来。
引完问题后作者是这样写作cotribution的，首先再强调一下motivation，也就是我们觉得只用全局不好使。在具体工作上可以分为三个部分，其一是mam，这是一个嵌在resnet50 backbone中的结构，它使用带通道注意力的IN减小模态分布上的gap，其二pam结构用来生成几种不同的空间注意力权重，作者把这个叫做patters，也就是期望不同的attention map能关注不同语义的局部特征，其三，拼接局部和全局特征后，使用互学习的思想，其中添加的loss一方面拉近了用两种模态特征得到的id预测的分布，另一方面又驱使模型根据当前输入模态学习，也就是给一个约束来减小模态对齐的信息损失。
f F v r
首先来看mam模块，核心是MAM，
in公式写错
in在跨域 风格迁移
bn ln
经过in，不同模态的特征在同一个通道上的均值方差就一样，都是gamma beta了，原本不同模态的特征分布可能差异很大，但现在in可以从分布统计量上
缓解这种差异。利用这种方法在模型前头缓解模态之间的gap，可以让后续结构的训练更加简单。
作者还引了一片研究in相关的论文，其中说道in的作用是消除图像间视觉特征的不一致，但是也会因此丢掉一些信息。比如说一方面in不仅拉近了不同模态，也拉近了不同id特征的距离，那在识别匹配就变困难了。尤其是两层mam比较靠近输出端了，这两层输出对最终特征影响是比较大的,直接用in的话，实验效果证明很差。
既然in有好处有害处，那我们就把这个操作软化掉。首先考虑通道上的信息分解，每个通道的feature map能对应于整张输入图像，可以认为每个通道关注的是不同角度的语义信息，我们在这里加一个通道注意力机制，让模型学习到的注意力权重决定in的输出在最终输出中的占比。理论上，由于最后reid的idloss metric loss的存在，如果mam输入中某个通道包含了行人id相关的信息，那就弱化in的加权系数，如果某个通道无所谓，那就强化in的影响来缓解模态gap
mam backbone
senet

然后这个结构的作用就是我们一直在讲的，有些信息，可能是可以对齐，可以在模态间share的局部信息 但因为模态间这个信息差异比较大。它在模态对齐的loss上相比于更抽象的全局特征不占优势，因此模型会倾向忽略这些信息，那这些信息就留在模态内部了，也就是模态融合后就学不到这些信息了。所以作者在这部分loss设计上首先给不同模态输入用了不同的预测头计算id loss，驱使模型尽可能多地利用上某一个模态下和人员id相关的信息。
另一方面，kl loss指引下，特征过不同模态的预测头的输出分布趋近，也就是驱使模型从两个模态中抽离出更多的与模态无关，或者说模态共享的信息。这样就打到模态对齐效果
那么在两个loss的对抗的作用下，我们理论上就能尽可能利用上两个模态下有用的信息。
但还记得对比学习吗，如果loss有一个捷径解，那么网络可能就会坍塌到这个捷径解，在kl loss中捷径解是两模态的分类器参数趋同，而且是linear layer... 因此动量更新...保证classier趋同之前有足够的时间来对齐可见光和红外的特征。最后，因为两个模态的特征已经对齐，所以我们就可以把两个特征平等来看，进行id loss和中心损失的训练，这里的id loss两个模态用同一个分类器







